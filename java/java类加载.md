## 虚拟机类加载机制学习笔记

### 生命周期 

加载 验证 准备 解析 初始化 使用 卸载

### 初始化时机

- 遇到new, getstatic, putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，刚需要先触发其初始化。使用new关键字实例化对象，读取或设置一个类的静态字段(被final修饰，已在编译期把结果放入常量池的静态字段除外)，以及调用一个类的静态方法时
- 使用java.lang.reflectq包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
- 如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化

   简单来说，对一个类进行主动引用，要先将其初始化

### 类加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 数组加载

- 如果数组的组件类型(Component Type, 指的是数组去掉一个维度的类型)是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识
- 如果数组的组件类型不是引用类型， Java虚拟机将会把数组C标记为与引导类加载器关联
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public 

### 验证

-  文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

### 准备

   准备阶段是正式为类变量分配内存并设置类变量初始值阶段，这些变量所使用的内存将在方法区进行分配， 如果类字段属性表存在ConstantValue属性，准备阶段就会被初始化为ConsantValue

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

符号引用用一组符号来描述引用的目标，符号可以是任何形式的字面量, 只要使用时能无歧义定位到目标即哥。

直接引用是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。

### 初始化

类初始化是类加载的最后一步，执行定义的java程序代码

### 类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

启动类加载器负责将JAVA_HOME\lib目录中的，或者被-Xbootclasspath参数指定路径，并且是虚拟机能识别的类库加载到虚拟机内存中

扩展类加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载JAVA_HOME\lib\ext目录或都被java.ext.dirs系统变量所指定的路径中的所有类库

应用程序类加载器由sun.misc.Launcher$AppClassLoader实现, 它负责加载用户类路径上所指定的类库

